# Context
The control system has 4 main components: the interactive map, the server controls & metrics, the plot controls & metrics, and the growth controls.

The map shows a view of all the plots. Each plot on the map has a number which corresponds to its position on the plot list. A red plot is unoccupied and a green one is occupied – this means that it has growth requirements stored on the database. Clicking on one of the plots on the map selects that specific plot in the list and, if it is occupied, all data regarding it will be shown.

The plot list is made up of all the plots on the map in order. Each listing has an indicator light which can turn red/green/orange. Green means the plot is occupied, red is unoccupied, and orange means that the crop in the plot is ready for harvesting. Beside the plot list are the metrics for the currently selected plot. It shows a live feed of the plot's sensor data and the statuses of the sprinkler, fertilizer, and environment modifiers that are connected to it.

The interface above the plot list consists of buttons that allow the user to interact with the back end. The add and edit buttons show/hide HTML forms that specify a crop's growth requirements, whereas the delete button gets rid of the currently selected plot's data from the system (i.e. it deletes the plot's growth requirements and the system stops tracking its metrics). The interface also has a countdown timer that tells the user how long until the crop is ready to harvest.

The server list is similar to the plot list. Selecting a server allows the user to see its status (the indicator lights also show this; green for online & red for offline) and what sensor variable it collects. The restart button turns a server off temporarily and the deactivate button keeps it off until it is activated again. When a server goes offline, the data for its variable disappears from the plot metrics.

The growth control switches enable the user to manually change the environment of a crop. One important thing to note is that they only affect the currently selected plot. Turning them on or off changes the statuses of its sprinkler, fertilizer, and modifiers – the sensor data of the plot will also change as a result of the new environment. By default, the control system is the one who turns these components on/off. It does so whenever it sees the sensor data not meeting the growth requirements of the plot.<br><br>

# Mechanism behind the sensor data & growth automation
To add a crop to the system, its growth requirements are provided. These requirements represent the crop itself. Plots also represent crops, so each set of requirements is mapped to a plot. In the back end, a class called PlotSensorDataReceiver is initialized for every plot that is occupied. This class is responsible for generating the sensor data that can be seen in the plot metrics, and because of that, it also simulates the growth automation (i.e. the correction of sensor data values). Each receiver instance is given the growth requirements for the plot it represents, it compares these requirements with the random sensor data values it generates and adjusts the random values to meet the growth requirements (analogous to the system maintaining the crop). This is only the basic idea, however, the generation of the random values is much more complicated. It can be separated into three categories: fluctuations, automated control, and manual control. In real life the environment is not constant. Slight variations can occur in environmental variables and the sensors will pick these up - this is called fluctuation. When neither the system nor the user is doing anything to a plot, its random sensor data generator, a method called __collectNewData, mimics fluctuation by generating a slight variation of the previous sensor data. Every 30 seconds, the system will do the comparison for each sensor variable. If it sees that a variable is not meeting one of the conditions in the plot’s growth requirements, it will provide the random generator with conditions in order for it to generate a value that does meet the requirements - this is automated control (i.e. growth automation). Manual control, on the other hand, is when the user provides the random generator with their own conditions which may or may not meet the growth requirements. All of this is possible because of threading. Each receiver instance has a recursive method called “listen” that creates a thread which does the random generation in the background.
